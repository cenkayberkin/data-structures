#Queue implemented
enqueue(value): adds value to the queue
dequeue(): removes the correct item from the queue and returns its value (should raise an exception if the queue is empty)
size(): return the size of the queue. Should return 0 if the queue is empty.


[![Build Status](https://travis-ci.org/cenkayberkin/data-structures.svg?branch=queue)](https://travis-ci.org/cenkayberkin/data-structures)
#Quick sort implementation
>Quick sort is usually the fastest sorting algorithm, unless bad pivots are chosen.

#Merge sort implementation

>Merge sort is ideal if you want a stable sort algorithm, its worst case scenario and best case wont change, it O(NlgN)

#Insertion sort implementation

>Insertion is ideal for almost sorted arrays and situation when there is no extra space except sorting array.
>i have implemented common algorithm insertion sort, worst case scenario would be if the array is reveresed.

Time complexity is:
worst case: O(n^2)
best case: O(n) if it is sorted already.
